// File internal/game/gameflow.go
package game

/*
该文件翻译自 Haskell 的 `Game` 模块，负责游戏状态机
（Phase 1 放子 → Phase 2 跳子 → 结算）以及交互循环的
最小实现。所有与 UI / 网络 无关的纯逻辑都应放在
`internal/game` 包内，方便 CLI、GUI 等多种前端复用。
*/

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

// -----------------------------------------------------------------------------
// 初始状态 & 基础工具
// -----------------------------------------------------------------------------
// StartState 返回一局新 DVONN 的初始状态
func StartState() GameState {
	return GameState{
		Board: EmptyDvonn,
		Turn:  Start,
		Phase: Phase1,
	}
}

func prompt(t TurnState) string {
	switch t {
	case PlacingRed:
		return "Place a red piece"
	case PlacingWhite:
		return "Place a white piece"
	case PlacingBlack:
		return "Place a black piece"
	case MoveWhite:
		return "White move"
	case MoveBlack:
		return "Black move"
	default:
		return "UnknownTurnState"
	}
}

func readLine() string {
	r := bufio.NewReader(os.Stdin)
	s, _ := r.ReadString('\n')
	return strings.TrimSpace(s)
}

func printErr(e GameError) {
	switch e {
	case MoveParseError:
		fmt.Println("You entered a malformed move.")
	case InvalidMove:
		fmt.Println("Your move was incorrect.")
	default:
		fmt.Println("Unknown error.")
	}
}

// -----------------------------------------------------------------------------
// 获取玩家输入（若后续完全改为 GUI，可移除）
// -----------------------------------------------------------------------------

//	func getTurnInput(gs *GameState) Move {
//		for {
//			fmt.Println()
//			fmt.Printf("%s > ", prompt(gs.Turn)) // 提示
//
//			raw := readLine()
//			mv, err := ParseMove(raw, gs.Turn) // TODO: 如弃用 CLI，可删除
//			if err != nil {
//				printErr(MoveParseError)
//				continue
//			}
//			return mv
//		}
//	}
func getTurnInput(gs *GameState) Move {
	// We don't use text input in the GUI version; all moves
	// are generated by mouse events in the Ebiten layer.
	return nil
}

// -----------------------------------------------------------------------------
// 执行走子
// -----------------------------------------------------------------------------

func ExecuteMove(gs *GameState, mv Move) {
	// 验证走子合法性
	if !ValidMove(&gs.Board, mv) {
		printErr(InvalidMove)
		return
	}

	// 应用走子，apply 返回新的 Board
	gs.Board = apply(mv, &gs.Board)

	switch m := mv.(type) {
	case JumpMove:
		gs.Turn = getNextTurn(&gs.Board, m.Player)
	case PlaceMove:
		// 放子阶段顺序由 runPlacementPhase 控制
	}

	// 检查是否仍有合法跳子
	if !HasAnyLegalMoves(&gs.Board, gs.Turn) {
		gs.Turn = End
	}
}

// -----------------------------------------------------------------------------
// Phase 1 — 放子
// -----------------------------------------------------------------------------

func runPlacementPhase(gs *GameState) {
	order := []TurnState{PlacingRed, PlacingRed, PlacingRed}
	for i := 0; i < 46; i++ {
		if i%2 == 0 {
			order = append(order, PlacingBlack)
		} else {
			order = append(order, PlacingWhite)
		}
	}
	for _, ts := range order {
		gs.Turn = ts
		mv := getTurnInput(gs)
		ExecuteMove(gs, mv)
	}
}

// -----------------------------------------------------------------------------
// Phase 2 — 跳子
// -----------------------------------------------------------------------------

func runMovementPhase(gs *GameState) *Player {
	for gs.Turn != End {
		mv := getTurnInput(gs)
		ExecuteMove(gs, mv)
	}
	return calcWinner(&gs.Board)
}

// -----------------------------------------------------------------------------
// Dvonn — 完整对局
// -----------------------------------------------------------------------------

func Dvonn() *Player {
	gs := StartState()

	fmt.Println(summary1)
	fmt.Println(summary2)

	runPlacementPhase(&gs)
	gs.Phase, gs.Turn = Phase2, MoveBlack // 跳子阶段黑先
	return runMovementPhase(&gs)
}

// -----------------------------------------------------------------------------
// 规则摘要（原样保留）
// -----------------------------------------------------------------------------

var summary1 = `Welcome to DVONN.

In Phase 1, you must place your pieces one by one on
unoccupied spaces on the game board. White will begin
and players will alternate placing. Place your red
pieces first, and then proceed to place your normal pieces.
White has two red pieces and Black has one red piece.

To place a piece, use the command <coord>, for example, "A3".`

var summary2 = `
In Phase 2, you may move any stack of height n with your color
piece on top to be on top of another stack that is exactly
n hops away. Be careful, though! Any stacks that are not
in a connected component with a red piece will be discarded.
Whoever controls the most pieces at the end wins!

To jump, use the command <start> "to" <end>, for example "A1 to A3".`
